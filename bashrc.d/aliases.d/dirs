#!bash
# vim:set ft=sh tabstop=2 softtabstop=2 shiftwidth=2 expandtab autoindent copyindent :



#----------- DIRS -----------

unalias D 2>/dev/null
function D ()
{
  echo # to visually separate from prompt, which likely also includes the current path
  dirs -v
  echo # to visually separate from prompt, which likely also includes the current path
  #
  # Alternately, could define in terms of DIRS, a shell+perl script that
  # factors out common strings to reduce display complexity.  Left as an
  # exercise for the future.  The current DIRS.pl needs work, and should
  # be implemented as a native bash function anyway.
}

unalias d 2>/dev/null
function d ()
{ # like `dirs -v` but with with edits to add context and usually shorten
  local head="$1" ; shift
  if [ -z "$head" ] ; then head=9 ; fi
  local f g R i=0 n
  local gitroot
  local orig
  echo
  while read f
  do
    orig="$f"
    n="$i"
    i=$(( i + 1 ))
    if [ $n -gt $head ]
    then
      continue
    fi
    if [ "$f" = '~' ]
    then
      printf "%2d  %s\n" $n "$f"
      continue
    fi
    g="${f#~\/}"
    if [ "$g" != "$f" ]
    then
      f="${HOME}/$g"
    fi
    g="$( cd "$f" && git rev-parse --is-inside-work-tree 2>/dev/null )"
    R=$?
    if [ $R -eq 0 ] && [ "$g" = true ]
    then # is a git path
      gitroot="$( cd "$f" && git rev-parse --show-toplevel 2>/dev/null )"
    fi
    if [ $R -eq 0 ] && [ "$g" = true ] && [ "$gitroot" != "$f" ]
    then # is a git path
      f="${f#$gitroot\/}"
      printf "%2d  %s\n" $n "$(cd "$gitroot" && basename -s .git "$(git config --get remote.origin.url)"):${f#$gitroot\/}"
      continue
    else # is not in git or is at root of a git
      printf "%2d  %s\n" $n "$orig"
      continue
    fi
  done <<<"$(dirs -p)"
  if [ $n -gt $head ]
  then
    printf "...\n"
    printf "%2d  ?\n" $n
  fi
  echo
}

function pd ()
{ # like builtin pushd, but smarter
  if [ $# -eq 0 ]
  then
    builtin pushd >/dev/null || return
    d
    return
  fi
  # pushes onto stack in reverse order so that the first argument will be on top of the stack
  local i d
  for ((i=$#;i>0;i--))
  do
    d="${!i}"
    if [ -z "$d" ]
    then
      # treat '' as lack of an argument instead of just complaining
      builtin pushd >/dev/null || return
    elif [ "$(dirs -p)" = '~' ]
    then
      builtin cd "$d" >/dev/null || return
    else
      builtin pushd "$d" >/dev/null || return
    fi
  done
  d
}
function pd- () { pd -1 "$@" ; }

# DIRS is a shell+perl script that factors out common strings to reduce display complexity
alias diirs='DIRS'  # or 'dirs -v' in a pinch
alias dirss='DIRS'  # or 'dirs -v' in a pinch
alias diirs='dirs -v'
alias dirss='dirs -v'
unalias diirs
unalias dirss

function PUSHD ()
{
  pd "$@"
}

function popd ()
{
  builtin popd "$@" >/dev/null
  local R=$?
  d
  return $R
}

function POPD ()
{
  popd "$@"
}

function UP ()
{
  local n=1
  if [ -n "$1" ]
  then
    n="$1" ; shift
  fi
  PUSHD +$n
}

function DOWN ()
{
  local n=1
  if [ -n "$1" ]
  then
    n="$1" ; shift
  fi
  n=$(( n - 1 ))
  PUSHD -$n
}
alias Down=DOWN
